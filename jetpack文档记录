jetpack组件---Navigation
一、是什么？
1.是一个可简化Android导航的库和插件
2.Navigation是用来管理Fragment的切换，并且可以通过可视化的方式，看见App的交互流程

二、优点
1.处理Fragment的切换（上文已说过）
2.默认情况下正确处理Fragment的前进和后退
3.为过渡和动画提供标准化的资源
4.实现和处理深层连接
5.可以绑定Toolbar、BottomNavigationView和ActionBar等
6.SafeArgs（Gradle插件） 数据传递时提供类型安全性
7.ViewModel支持

三、最关键的三要素
1.Navigation Graph(New XML resource)：这是一个新的资源文件，用户在可视化界面可以看出他能够到达的Destination(用户能够到达的屏幕界面)，以及流程关系
2.NavHostFragment(Layout XML view)：当前Fragment的容器
3.NavController(Kotlin/Java object)：导航的控制者

四、利用SafeArgs传值
1.在项目目录下的build.gradle文件中添加 classpath "androidx.navigation:navigation-safe-args-gradle-plugin:$navigationVersion"
2.模块下面的build.gradle文件添加 apply plugin: 'androidx.navigation.safeargs'
3.login_navigation.xml中
    <fragment
        android:id="@+id/register"
        android:name="com.example.jetpack.ui.fragment.login.RegisterFragment"
        android:label="RegisterFragment"
        tools:layout="@layout/fragment_register">
        <argument
            android:name="EMAIL"
            android:defaultValue="2005@qq.com"
            app:argType="string" />
        <argument
            android:name="account"
            android:defaultValue="xixi"
            app:argType="string" />
        <argument
            android:name="password"
            android:defaultValue="xixi"
            app:argType="string" />
    </fragment>
(1)a.name:标签名字
b.defaultValue:默认值
c.argType:标签类型
(2)编写完成后 点击Android studio中的Make Project按钮

五、Navigation可以绑定menus、drawers和bottomnavigation

六、回退栈
1.NavController.popBackStack()和NavController.navigateUp() 可以返回指定的目标
2.app:popUpTo:A->B->C,如果再从C->A意味着我们在导航的时候从回退栈中删除了 B,C。
3.app:popUpToInclusive="true" 我们同时弹出了回退栈中的第一个 A.要注意如果你没有使用，你的回退栈中将会包含两个A 的实例.



==================================================== 分割线 ====================================================
jetpack组件---Data Binding
一、MVVM模式
1.View层：xml、Activity、Fragment、Adapter和View等
2.Model层：数据源（本地数据和网络数据等）
3.ViewModel层：View层处理数据以及逻辑处理

二、Data Binding介绍
1.MVVM是一种架构模式
2.Data Binding是一个实现数据和UI绑定的框架，是构建MVVM模式的一个工具

三、实战步骤
1.app模块下的build.gradle文件添加内容
    dataBinding {
       enabled true
    }

2.创建登录的LoginModel，LoginModel主要负责登录逻辑的处理以及两个输入框内容改变的时候数据更新的处理
(1)ObservableField:其实是一个可观察的域，通过泛型来使用，可以使用的方法
a.ObservableField(T value) 构造函数，设置可观察的域
b.T get() 获取可观察的域的内容，可以使用UI控件监测它的值
c.set(T value) 设置可观察的域，设置成功之后，会通知UI控件进行更新

3.创建布局文件
(1)引入Data Binding之后的布局文件的使用方式会和以前的布局使用方式有很大的不同
(2)布局文件fragment_login2.xml
a.layout:用作布局的根节点，只能包裹一个View标签，且不能包裹merge标签。
b.data:Data Binding的数据，只能存在一个data标签。
c.variable:data中使用，数据的变量标签，type属性指明变量的类，如com.example.jetpack.ui.viewmodel.LoginModel。name属性指明变量的名字，方便布局中使用。
d.import:data中使用，需要使用静态方法和静态常量，如需要使用View.Visble属性的时候，则需导入<import type="android.view.View"/>。
type属性指明类的路径，如果两个import标签导入的类名相同，则可以使用alias属性声明别名，使用的时候直接使用别名即可。
e.include:View标签中使用，作用同普通布局中的include一样，需要使用bind:<参数名>传递参数

4.Data Binding还支持
运算符 + - / * %
字符串连接 +
逻辑与或 && ||
二进制 & | ^
一元 + - ! ~
移位 >> >>> <<
比较 == > < >= <= (Note that < needs to be escaped as <)
instanceof
Grouping ()
Literals - character, String, numeric, null
Cast
方法调用
域访问
数组访问
三元操作符

5.生成绑定类
布局文件创建完毕之后，点击Build下面的Make Project，让系统帮我生成绑定类

==================================================== 分割线 ====================================================
jetpack组件---ViewModel & LiveData

一、LiveData的作用
1.ViewModel和LiveData在整个MVVM架构中担当数据驱动的职责，这也是MVVM模式中ViewModel层的作用
2.LiveData作用跟RxJava类似，是观察数据的类，相比RxJava，它能够在Activity、Fragment和Service之中正确的处理生命周期

二、LiveData的优点
1.数据变更的时候更新UI
2.没有内存泄漏
3.不会因为停止Activity崩溃
4.无需手动处理生命周期
5.共享资源

三、使用方式
1.observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer)：
最常用的方法，需要提供Observer处理数据变更后的处理。LifecycleOwner则是我们能够正确处理声明周期的关键！
2.setValue(T value)：设置数据
3.getValue():T ：获取数据
4.postValue(T value)：在主线程中更新数据

四、配合使用
绝大部分的LiveData都是配合其他Android Jetpack组件使用的

五、ViewModel
1.ViewModel同样具有生命周期意识的处理跟UI相关的数据，并且，当设备的一些配置信息改变（例如屏幕旋转）它的数据不会消失
2.ViewModel的另一个特点就是同一个Activity的Fragment之间可以使用ViewModel实现共享数据

六、viewmodel的使用方法
1.继承ViewModel即可

七、LiveData如何共享数据
1.两个fragment有同一个activity

==================================================== 分割线 ====================================================
jetpack组件---Room数据库

一、Room是一个基于SQLite的强大数据库框架

二、room的优点
1.使用编译时注解，能够对@Query和@Entity里面的SQL语句等进行验证。
2.与SQL语句的使用更加贴近，能够降低学习成本。
3.对RxJava 2的支持（大部分都Android数据库框架都支持），对LiveData的支持。
4.@Embedded能够减少表的创建。

三、组件组成
1.Room由三个重要的组件组成：Database、Entity、DAO。
(1).Database：包含数据库持有者，并作为与应用持久关联数据的底层连接的主要访问点
(2).Database对应的类必须满足下面几个条件:
a.必须是abstract类而且的extends RoomDatabase
b.必须在类头的注释中包含与数据库关联的实体列表(Entity对应的类)
c.包含一个具有0个参数的抽象方法，并返回用@Dao注解的类
(3)获取Database实例:在运行时，你可以通过Room.databaseBuilder() 或者 Room.inMemoryDatabaseBuilder()
(4).Entity：代表数据库中某个表的实体类。
(5).DAO：包含用于访问数据库的方法。

四、添加依赖
在项目的build.gradle文件中 room 标签下

五.创建表
(1)注解理解：
a.@Entity：声明这是一个表（实体），主要参数：tableName-表名、foreignKeys-外键、indices-索引。
b.@ColumnInfo:主要用来修改在数据库中的字段名。
c.@PrimaryKey:声明该字段主键并可以声明是否自动创建
d.@Ignore:声明某个字段只是临时用，不存储在数据库中。
e.@Embedded:用于嵌套，里面的字段同样会存储在数据库中。

4.建立数据处理的方法，就是数据的增删查改。如果想声明一个Dao，只要在抽象类或者接口加一个@Dao注解就行
(1)增删改查方法：
a.@Insert:注解声明当前的方法为新增的方法
b.@Delete:注解声明当前的方法是一个删除方法
c.@Update:注解声明当前方法是一个更新方法
d.@Query:注解不仅可以声明这是一个查询语句，也可以用来删除和修改，不可以用来新增

5.创建数据库
创建一个数据库对象是一件非常消耗资源，使用单例可以避免过多的资源消耗
(1)@Database注解声明当前是一个数据库文件
(2)注解中entities变量声明数据库中的表（实体）

6.数据库升级、迁移
(1).Room里面以Migration类的形式提供可一个简化SQLite迁移的抽象层。Migration提供了从一个版本到另一个版本迁移的时候应该执行的操作
(2).版本1的时候添加allowMainThreadQueries()
(3).版本1到版本2的时候添加addMigrations(MIGRATION_1_2) MIGRATION_1_2为方法
(4).版本2到版本3的时候添加addMigrations(MIGRATION_1_2,MIGRATION_2_3)MIGRATION_1_2,MIGRATION_2_3 都是方法

==================================================== 分割线 ====================================================
jetpack组件---Paging

一、








==================================================== 分割线 ====================================================